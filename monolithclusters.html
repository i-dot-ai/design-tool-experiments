<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monolith Clusters - Generative Art</title>
    <!-- Dependencies: Tailwind for UI, Three.js for 3D, and SVG extensions -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/Projector.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/SVGRenderer.js"></script>
    <style>
        body {
            background-color: #f8f8f8;
            margin: 0;
            overflow: hidden;
            user-select: none;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        }

        canvas {
            display: block;
        }

        .control-panel {
            backdrop-filter: blur(12px);
            background-color: rgba(255, 255, 255, 0.85);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
        }

        .control-panel.ui-hidden {
            transform: translate(calc(100% + 2rem), -50%);
            opacity: 0;
            pointer-events: none;
        }

        input[type="range"] {
            accent-color: #000;
            cursor: pointer;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 24px;
            height: 24px;
            padding: 0;
            border-radius: 4px;
            cursor: pointer;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .segmented-control {
            display: flex;
            background: rgba(0, 0, 0, 0.05);
            padding: 2px;
            border-radius: 8px;
            width: 100%;
        }

        .segmented-control button {
            flex: 1;
            padding: 6px 0;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: bold;
            border-radius: 6px;
            transition: all 0.2s ease;
            color: rgba(0, 0, 0, 0.4);
        }

        .segmented-control button.active {
            background: white;
            color: black;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .rando-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.03);
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .rando-toggle.active {
            background: #000;
            color: white;
        }

        .rando-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.2);
        }

        .active .rando-dot {
            background: #fff;
            box-shadow: 0 0 8px #fff;
        }
    </style>
</head>

<body class="flex flex-col h-screen">

    <button id="uiToggle"
        class="absolute bottom-6 right-6 z-30 bg-black text-white px-4 py-2 rounded-full text-[10px] uppercase font-bold hover:bg-zinc-800 shadow-xl transition-all active:scale-95">
        Hide UI
    </button>

    <div id="controlPanel"
        class="control-panel absolute top-1/2 right-6 -translate-y-1/2 z-10 p-8 rounded-3xl border border-black/5 shadow-2xl flex flex-col items-center gap-8 w-[300px] max-h-[90vh] overflow-y-auto">
        <div class="w-full text-black border-b border-black/5 pb-6">
            <h1 class="text-xl font-bold tracking-tighter uppercase leading-tight text-black">Monolith Clusters</h1>
            <p class="text-[9px] text-gray-400 tracking-wider uppercase italic mt-1">Drag to rotate • Scroll to zoom
            </p>
        </div>

        <div class="flex flex-col gap-6 w-full text-black">
            <div class="flex flex-col gap-2">
                <div class="flex justify-between text-[10px] uppercase font-bold text-black">
                    <label>Density</label>
                    <span id="qtyVal">80</span>
                </div>
                <input type="range" id="boxCount" min="15" max="300" value="80" class="w-full">
            </div>

            <div class="flex flex-col gap-2">
                <div class="flex justify-between text-[10px] uppercase font-bold text-black">
                    <label>Variance</label>
                    <span id="varVal">7</span>
                </div>
                <input type="range" id="variation" min="1" max="10" step="1" value="7" class="w-full">
            </div>

            <div class="flex flex-col gap-2">
                <div class="flex justify-between text-[10px] uppercase font-bold text-black">
                    <label>Chonk</label>
                    <span id="conVal">5</span>
                </div>
                <input type="range" id="contrast" min="1" max="10" step="1" value="5" class="w-full">
            </div>

            <div class="flex flex-col gap-2">
                <div class="flex justify-between text-[10px] uppercase font-bold text-black">
                    <label>Perspective</label>
                    <span id="perspectiveVal">45°</span>
                </div>
                <!-- 0 = Ortho, 50 = Normal (Default), 100 = Extreme -->
                <input type="range" id="perspectiveInput" min="0" max="100" step="1" value="50" class="w-full">
            </div>

            <div class="flex flex-col gap-2">
                <label class="text-[10px] uppercase font-bold text-black opacity-50">Render Mode</label>
                <div class="segmented-control" id="modeControl">
                    <button data-mode="solid" class="active">Solid</button>
                    <button data-mode="wireframe">Wire</button>
                    <button data-mode="borderless">Plain</button>
                </div>
            </div>

            <div id="randoToggle" class="rando-toggle">
                <label class="text-[10px] uppercase font-bold pointer-events-none">Rando Mode</label>
                <div class="rando-dot"></div>
            </div>
        </div>

        <div class="flex flex-col gap-8 w-full border-t border-black/5 pt-6">
            <div class="flex flex-col gap-4">
                <div class="flex items-center justify-between w-full">
                    <label class="text-[10px] uppercase font-bold text-black">Background</label>
                    <input type="color" id="bgColor" value="#f8f8f8">
                </div>
                <div class="flex items-center justify-between w-full">
                    <label class="text-[10px] uppercase font-bold text-black">Primary Light</label>
                    <input type="color" id="keyLightColor" value="#ffffff">
                </div>
                <div class="flex items-center justify-between w-full">
                    <label class="text-[10px] uppercase font-bold text-black">Accent Light</label>
                    <input type="color" id="fillLightColor" value="#ffffff">
                </div>
            </div>

            <div class="flex flex-col gap-3">
                <button id="refreshBtn"
                    class="w-full bg-black text-white px-6 py-3 rounded-xl text-xs uppercase font-bold hover:bg-zinc-800 transition-colors active:scale-95">
                    Regenerate
                </button>
                <button id="exportSvgBtn"
                    class="w-full border border-zinc-300 px-6 py-3 rounded-xl text-xs uppercase font-bold hover:bg-black hover:text-white transition-all">
                    Export SVG
                </button>
            </div>
        </div>
    </div>

    <div id="canvas-container" class="w-full h-full"></div>

    <script>
        let scene, renderer, group;
        let perspectiveCamera, orthographicCamera, activeCamera;
        let keyLight, fillLight;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotation = { x: 0.5, y: 0.5 };
        let currentRotation = { x: 0.5, y: 0.5 };
        let renderMode = 'solid';
        let randoMode = false;
        let lastRandoTime = 0;
        let uiHidden = false;
        let rects = [];
        let baseUnit = 20;

        // Perspective Constants
        const INITIAL_FOV = 45;
        const INITIAL_DIST = 1200;
        const VISIBLE_HEIGHT = 2 * INITIAL_DIST * Math.tan((INITIAL_FOV * Math.PI / 180) / 2);

        const boxCountInput = document.getElementById('boxCount');
        const variationInput = document.getElementById('variation');
        const contrastInput = document.getElementById('contrast');
        const refreshBtn = document.getElementById('refreshBtn');
        const exportSvgBtn = document.getElementById('exportSvgBtn');
        const keyColorInput = document.getElementById('keyLightColor');
        const fillColorInput = document.getElementById('fillLightColor');
        const bgColorInput = document.getElementById('bgColor');
        const uiToggle = document.getElementById('uiToggle');
        const controlPanel = document.getElementById('controlPanel');
        const modeControl = document.getElementById('modeControl');
        const randoToggle = document.getElementById('randoToggle');
        const qtyDisplay = document.getElementById('qtyVal');
        const varDisplay = document.getElementById('varVal');
        const conDisplay = document.getElementById('conVal');
        const perspectiveInput = document.getElementById('perspectiveInput');
        const perspectiveVal = document.getElementById('perspectiveVal');

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(bgColorInput.value);

            const aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera = new THREE.PerspectiveCamera(INITIAL_FOV, aspect, 1, 10000);
            perspectiveCamera.position.z = INITIAL_DIST;

            orthographicCamera = new THREE.OrthographicCamera(
                -VISIBLE_HEIGHT * aspect / 2,
                VISIBLE_HEIGHT * aspect / 2,
                VISIBLE_HEIGHT / 2,
                -VISIBLE_HEIGHT / 2,
                1,
                10000
            );
            orthographicCamera.position.z = INITIAL_DIST;
            activeCamera = perspectiveCamera;

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            keyLight = new THREE.DirectionalLight(0xffffff, 0.6);
            keyLight.position.set(500, 1000, 500);
            scene.add(keyLight);
            fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-500, 200, 200);
            scene.add(fillLight);
            group = new THREE.Group();
            scene.add(group);

            // Interaction Listeners
            window.addEventListener('mousedown', (e) => {
                if (e.target.closest('#controlPanel') || e.target.closest('#uiToggle')) return;
                isDragging = true;
                document.body.style.cursor = 'none';
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                document.body.style.cursor = 'default';
            });

            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = { x: e.offsetX - previousMousePosition.x, y: e.offsetY - previousMousePosition.y };
                    targetRotation.y += deltaMove.x * 0.01;
                    targetRotation.x += deltaMove.y * 0.01;
                    if (randoMode && Date.now() - lastRandoTime > 80) {
                        morph();
                        lastRandoTime = Date.now();
                    }
                }
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });

            window.addEventListener('wheel', (e) => {
                if (e.target.closest('#controlPanel') || e.target.closest('#uiToggle')) return;

                if (activeCamera.isPerspectiveCamera) {
                    activeCamera.position.z += e.deltaY * 0.5;
                    activeCamera.position.z = Math.min(Math.max(activeCamera.position.z, 200), 3000);
                } else {
                    orthographicCamera.zoom -= e.deltaY * 0.001;
                    orthographicCamera.zoom = Math.max(0.1, Math.min(orthographicCamera.zoom, 5));
                    orthographicCamera.updateProjectionMatrix();
                }
            }, { passive: false });

            window.addEventListener('resize', onWindowResize);
            animate();
            generate();
        }

        function updatePerspective() {
            const rawVal = parseInt(perspectiveInput.value);

            if (rawVal < 2) {
                activeCamera = orthographicCamera;
                perspectiveVal.innerText = "Ortho";
            } else {
                let fov;
                if (rawVal <= 50) {
                    fov = 1 + (rawVal - 2) * (44 / 48);
                } else {
                    fov = 45 + (rawVal - 50) * (85 / 50);
                }

                perspectiveVal.innerText = Math.round(fov) + "°";

                activeCamera = perspectiveCamera;
                activeCamera.fov = fov;

                // Dolly Zoom: Maintain visible height at the scene center
                const dist = VISIBLE_HEIGHT / (2 * Math.tan((fov * Math.PI / 180) / 2));
                activeCamera.position.z = dist;
                activeCamera.updateProjectionMatrix();
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;

            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            orthographicCamera.left = -VISIBLE_HEIGHT * aspect / 2;
            orthographicCamera.right = VISIBLE_HEIGHT * aspect / 2;
            orthographicCamera.top = VISIBLE_HEIGHT / 2;
            orthographicCamera.bottom = -VISIBLE_HEIGHT / 2;
            orthographicCamera.updateProjectionMatrix();
        }

        function morph() {
            boxCountInput.value = Math.floor(Math.random() * 200) + 20;
            variationInput.value = Math.floor(Math.random() * 10) + 1;
            contrastInput.value = Math.floor(Math.random() * 10) + 1;
            generate();
        }

        function subdivide(r, complexity, variation, contrast, currentDepth) {
            const rectCenterX = r.x + r.w / 2;
            const rectCenterY = r.y + r.h / 2;
            const dx = rectCenterX / 400;
            const dy = rectCenterY / 400;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const areaUnits = (r.w / baseUnit) * (r.h / baseUnit);
            const stopEarlyChance = 0.05 + (contrast * 0.04);
            if (areaUnits <= 1 || rects.length >= complexity || (currentDepth > 2 && Math.random() < stopEarlyChance)) {
                if (Math.random() < Math.pow(Math.max(0, 1.25 - dist), 1.8) || dist < 0.2) {
                    rects.push(r);
                }
                return;
            }
            let splitVertical = r.w > r.h;
            if (Math.random() < 0.1) splitVertical = !splitVertical;
            const dim = splitVertical ? r.w : r.h;
            const units = Math.floor(dim / baseUnit);
            if (units <= 1) { rects.push(r); return; }
            let splitIndex;
            const possibleSplits = [];
            for (let i = 1; i < units; i++) {
                if (variation > 3 && i === Math.floor(units / 2) && units > 2) continue;
                possibleSplits.push(i);
            }
            splitIndex = possibleSplits.length === 0 ? Math.floor(units / 2) : possibleSplits[Math.floor(Math.random() * possibleSplits.length)];
            const splitPos = splitIndex * baseUnit;
            if (splitVertical) {
                subdivide({ x: r.x, y: r.y, w: splitPos, h: r.h }, complexity, variation, contrast, currentDepth + 1);
                subdivide({ x: r.x + splitPos, y: r.y, w: r.w - splitPos, h: r.h }, complexity, variation, contrast, currentDepth + 1);
            } else {
                subdivide({ x: r.x, y: r.y, w: r.w, h: splitPos }, complexity, variation, contrast, currentDepth + 1);
                subdivide({ x: r.x, y: r.y + splitPos, w: r.w, h: r.h - splitPos }, complexity, variation, contrast, currentDepth + 1);
            }
        }

        function getShadedColor(normal, baseColorHex, kLight, fLight) {
            const base = new THREE.Color(baseColorHex);
            const keyCol = kLight.color;
            const fillCol = fLight.color;
            const n = normal.clone().normalize();
            const keyPos = kLight.position.clone().normalize();
            const keyDot = Math.max(0, n.dot(keyPos));
            const fillPos = fLight.position.clone().normalize();
            const fillDot = Math.max(0, n.dot(fillPos));
            const result = base.clone().multiplyScalar(0.4);
            result.add(keyCol.clone().multiplyScalar(keyDot * 0.7));
            result.add(fillCol.clone().multiplyScalar(fillDot * 0.4));
            return result;
        }

        function generate() {
            const complexity = parseInt(boxCountInput.value);
            const variation = parseInt(variationInput.value);
            const contrast = parseInt(contrastInput.value);
            qtyDisplay.innerText = complexity; varDisplay.innerText = variation; conDisplay.innerText = contrast;
            baseUnit = 20;
            while (group.children.length > 0) group.remove(group.children[0]);
            let attempts = 0;
            const masterDim = 800;
            const startRect = { x: -masterDim / 2, y: -masterDim / 2, w: masterDim, h: masterDim };
            do { rects = []; subdivide(startRect, complexity, variation, contrast, 0); attempts++; } while (rects.length < 10 && attempts < 20);

            const faceData = [
                { pos: [1, 0, 0], rot: [0, Math.PI / 2, 0], size: (w, h, d) => [d, h], normal: new THREE.Vector3(1, 0, 0) },
                { pos: [-1, 0, 0], rot: [0, -Math.PI / 2, 0], size: (w, h, d) => [d, h], normal: new THREE.Vector3(-1, 0, 0) },
                { pos: [0, 1, 0], rot: [-Math.PI / 2, 0, 0], size: (w, h, d) => [w, d], normal: new THREE.Vector3(0, 1, 0) },
                { pos: [0, -1, 0], rot: [Math.PI / 2, 0, 0], size: (w, h, d) => [w, d], normal: new THREE.Vector3(0, -1, 0) },
                { pos: [0, 0, 1], rot: [0, 0, 0], size: (w, h, d) => [w, h], normal: new THREE.Vector3(0, 0, 1) },
                { pos: [0, 0, -1], rot: [0, Math.PI, 0], size: (w, h, d) => [w, h], normal: new THREE.Vector3(0, 0, -1) }
            ];

            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });

            rects.forEach(r => {
                const depthUnits = Math.ceil(Math.random() * (contrast + 1));
                const depth = depthUnits * baseUnit;
                const monolithGroup = new THREE.Group();
                monolithGroup.position.set(r.x + r.w / 2, r.y + r.h / 2, depth / 2);

                faceData.forEach(face => {
                    const [fw, fh] = face.size(r.w, r.h, depth);
                    const geometry = new THREE.PlaneGeometry(fw, fh);
                    const bakedColor = getShadedColor(face.normal, 0xeeeeee, keyLight, fillLight);

                    const material = new THREE.MeshBasicMaterial({
                        color: bakedColor,
                        side: THREE.FrontSide,
                        transparent: renderMode === 'wireframe',
                        opacity: renderMode === 'wireframe' ? 0.1 : 1.0
                    });

                    const plane = new THREE.Mesh(geometry, material);
                    plane.position.set(face.pos[0] * r.w / 2, face.pos[1] * r.h / 2, face.pos[2] * depth / 2);
                    plane.rotation.set(...face.rot);
                    plane.userData.normal = { x: face.normal.x, y: face.normal.y, z: face.normal.z };
                    monolithGroup.add(plane);
                });

                const lineGeo = new THREE.BoxGeometry(r.w, r.h, depth);
                const edges = new THREE.EdgesGeometry(lineGeo);
                const line = new THREE.LineSegments(edges, edgeMaterial);
                line.visible = (renderMode !== 'borderless');
                monolithGroup.add(line);

                group.add(monolithGroup);
            });
        }

        function updateRenderState() {
            group.children.forEach(monolith => {
                monolith.children.forEach(child => {
                    if (child.type === 'Mesh') {
                        child.material.transparent = (renderMode === 'wireframe');
                        child.material.opacity = (renderMode === 'wireframe' ? 0.1 : 1.0);
                    } else if (child.type === 'LineSegments') {
                        child.visible = (renderMode !== 'borderless');
                    }
                });
            });
        }

        function updateLightColors() {
            keyLight.color.set(keyColorInput.value);
            fillLight.color.set(fillColorInput.value);

            // Re-bake shaded colors on existing geometry without regenerating the whole cluster
            group.children.forEach(monolith => {
                monolith.children.forEach(child => {
                    if (child.type === 'Mesh' && child.userData.normal) {
                        const normal = new THREE.Vector3(child.userData.normal.x, child.userData.normal.y, child.userData.normal.z);
                        const newBakedColor = getShadedColor(normal, 0xeeeeee, keyLight, fillLight);
                        child.material.color.copy(newBakedColor);
                    }
                });
            });
        }

        function updateBackground() {
            const color = bgColorInput.value;
            scene.background.set(color);
            document.body.style.backgroundColor = color;
        }

        function exportToSVG() {
            const exportScene = new THREE.Scene();
            exportScene.background = new THREE.Color(bgColorInput.value);

            const tempGroup = group.clone(true);
            exportScene.add(tempGroup);

            const renderables = [];
            const renderCam = activeCamera;
            const cameraPos = renderCam.position.clone();
            const worldQuat = new THREE.Quaternion();
            tempGroup.getWorldQuaternion(worldQuat);

            tempGroup.children.forEach(monolith => {
                monolith.children.forEach(child => {
                    child.updateMatrixWorld(true);

                    if (child.type === 'Mesh') {
                        const normalData = child.userData.normal;
                        if (normalData) {
                            const normal = new THREE.Vector3(normalData.x, normalData.y, normalData.z);
                            const faceNormal = normal.clone().applyQuaternion(worldQuat);

                            let toCamera;
                            if (renderCam.isOrthographicCamera) {
                                toCamera = new THREE.Vector3(0, 0, 1).applyQuaternion(renderCam.quaternion).normalize();
                            } else {
                                toCamera = cameraPos.clone().sub(child.getWorldPosition(new THREE.Vector3())).normalize();
                            }

                            if (faceNormal.dot(toCamera) > -0.1) {
                                renderables.push(child);
                            } else {
                                child.visible = false;
                            }
                        }
                    } else if (child.type === 'LineSegments' && renderMode !== 'borderless') {
                        renderables.push(child);
                    }
                });
            });

            renderables.sort((a, b) => {
                const distA = a.getWorldPosition(new THREE.Vector3()).distanceToSquared(cameraPos);
                const distB = b.getWorldPosition(new THREE.Vector3()).distanceToSquared(cameraPos);
                return distB - distA;
            });

            renderables.forEach((obj, index) => {
                obj.renderOrder = index;
            });

            const svgRenderer = new THREE.SVGRenderer();
            svgRenderer.setSize(window.innerWidth, window.innerHeight);
            svgRenderer.setQuality('high');
            svgRenderer.render(exportScene, renderCam);

            const XMLSerializer = window.XMLSerializer || (function () { return { serializeToString: (node) => node.outerHTML }; })();
            const serializer = new XMLSerializer();
            let svgNode = svgRenderer.domElement;

            const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            bgRect.setAttribute("width", "100%"); bgRect.setAttribute("height", "100%");
            bgRect.setAttribute("fill", bgColorInput.value);
            svgNode.insertBefore(bgRect, svgNode.firstChild);

            let svgData = '<?xml version="1.0" standalone="no"?>\n' + serializer.serializeToString(svgNode);
            if (!svgData.includes('xmlns="http://www.w3.org/2000/svg"')) {
                svgData = svgData.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
            }

            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url; link.download = `monolith-cluster-${Date.now()}.svg`;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function animate() {
            requestAnimationFrame(animate);
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;
            group.rotation.x = currentRotation.x;
            group.rotation.y = currentRotation.y;
            renderer.render(scene, activeCamera);
        }

        uiToggle.addEventListener('click', () => {
            uiHidden = !uiHidden;
            controlPanel.classList.toggle('ui-hidden', uiHidden);
            uiToggle.innerText = uiHidden ? "Show UI" : "Hide UI";
        });

        boxCountInput.addEventListener('input', generate);
        variationInput.addEventListener('input', generate);
        contrastInput.addEventListener('input', generate);
        refreshBtn.addEventListener('click', generate);
        exportSvgBtn.addEventListener('click', exportToSVG);
        keyColorInput.addEventListener('input', updateLightColors);
        fillColorInput.addEventListener('input', updateLightColors);
        bgColorInput.addEventListener('input', updateBackground);
        randoToggle.addEventListener('click', () => { randoMode = !randoMode; randoToggle.classList.toggle('active'); });

        modeControl.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                modeControl.querySelector('button.active').classList.remove('active');
                btn.classList.add('active');
                renderMode = btn.dataset.mode;
                updateRenderState();
            });
        });

        perspectiveInput.addEventListener('input', updatePerspective);
        window.onload = () => { initThree(); updatePerspective(); updateBackground(); };
    </script>
</body>

</html>