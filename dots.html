<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Dot Pattern Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: white;
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 5px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 2px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }

        /* Modern Range Input */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #22d3ee;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #374151;
            border-radius: 2px;
        }

        /* Checkbox Customization */
        input[type=checkbox] {
            accent-color: #22d3ee;
        }

        .control-group {
            margin-bottom: 1.25rem;
            padding-bottom: 1.25rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .control-group:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
    </style>
</head>

<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Controls -->
    <div id="controls"
        class="fixed top-4 right-4 w-80 bg-gray-900/90 backdrop-blur-md border border-gray-700/50 rounded-xl shadow-2xl flex flex-col max-h-[calc(100vh-2rem)] transition-all duration-300 z-50">

        <!-- Header -->
        <div class="px-5 py-4 border-b border-white/5 flex justify-between items-center bg-white/5">
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full bg-cyan-500 shadow-[0_0_8px_rgba(6,182,212,0.6)]"></div>
                <h1 class="text-sm font-bold text-white tracking-wide uppercase">Dots </h1>
            </div>
            <div class="flex items-center gap-1">
                <a href="kineticflow.html" title="Previous: Kinetic Flow"
                    class="text-gray-400 hover:text-white transition-colors p-1 hover:bg-white/10 rounded">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m15 18-6-6 6-6" />
                    </svg>
                </a>
                <a href="etherealblobs.html" title="Next: Ethereal Blobs"
                    class="text-gray-400 hover:text-white transition-colors p-1 hover:bg-white/10 rounded">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m9 18 6-6-6-6" />
                    </svg>
                </a>
                <div class="w-px h-4 bg-gray-700 mx-1"></div>
                <button id="toggle-ui"
                    class="text-gray-400 hover:text-white transition-colors p-1 hover:bg-white/10 rounded">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18" />
                        <path d="m6 6 12 12" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- Scrollable Content -->
        <div class="p-5 overflow-y-auto custom-scrollbar space-y-5">

            <!-- Colors -->
            <div class="control-group">
                <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-3">Appearance</h2>
                <div class="space-y-3">
                    <div class="flex items-center justify-between bg-black/20 p-2 rounded-lg border border-white/5">
                        <label class="text-xs text-gray-300 font-medium">Foreground</label>
                        <div class="flex items-center gap-2">
                            <span id="fg-hex" class="text-xs font-mono text-gray-500">#00ffff</span>
                            <input type="color" id="fg-color" value="#00ffff"
                                class="bg-transparent border-none w-6 h-6 p-0 cursor-pointer rounded overflow-hidden">
                        </div>
                    </div>
                    <div class="flex items-center justify-between bg-black/20 p-2 rounded-lg border border-white/5">
                        <label class="text-xs text-gray-300 font-medium">Background</label>
                        <div class="flex items-center gap-2">
                            <span id="bg-hex" class="text-xs font-mono text-gray-500">#051020</span>
                            <input type="color" id="bg-color" value="#051020"
                                class="bg-transparent border-none w-6 h-6 p-0 cursor-pointer rounded overflow-hidden">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pattern Settings -->
            <div class="control-group">
                <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-3">Grid Layout</h2>

                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs text-gray-300 font-medium">Density</label>
                            <span id="density-val"
                                class="text-xs font-mono text-cyan-400 bg-cyan-900/30 px-1.5 rounded">50</span>
                        </div>
                        <input type="range" id="density" min="10" max="100" value="50" class="w-full">
                    </div>

                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs text-gray-300 font-medium">Dot Size</label>
                            <span id="size-val"
                                class="text-xs font-mono text-cyan-400 bg-cyan-900/30 px-1.5 rounded">0.4</span>
                        </div>
                        <input type="range" id="dot-size" min="0.1" max="1.0" step="0.05" value="0.4" class="w-full">
                    </div>

                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs text-gray-300 font-medium">Curvature</label>
                            <span id="curve-val"
                                class="text-xs font-mono text-cyan-400 bg-cyan-900/30 px-1.5 rounded">0</span>
                        </div>
                        <input type="range" id="curvature" min="-5" max="5" step="0.1" value="0" class="w-full">
                    </div>

                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs text-gray-300 font-medium">Wave Effect</label>
                            <span id="wave-val"
                                class="text-xs font-mono text-cyan-400 bg-cyan-900/30 px-1.5 rounded">0</span>
                        </div>
                        <input type="range" id="wave" min="0" max="2" step="0.1" value="0" class="w-full">
                    </div>
                </div>
            </div>

            <!-- Rotation -->
            <div class="control-group">
                <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-3">Rotation</h2>

                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs text-gray-300 font-medium">Rotate X</label>
                            <span id="rot-x-val"
                                class="text-xs font-mono text-cyan-400 bg-cyan-900/30 px-1.5 rounded">0°</span>
                        </div>
                        <input type="range" id="rot-x" min="-180" max="180" value="0" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs text-gray-300 font-medium">Rotate Y</label>
                            <span id="rot-y-val"
                                class="text-xs font-mono text-cyan-400 bg-cyan-900/30 px-1.5 rounded">0°</span>
                        </div>
                        <input type="range" id="rot-y" min="-180" max="180" value="0" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs text-gray-300 font-medium">Rotate Z</label>
                            <span id="rot-z-val"
                                class="text-xs font-mono text-cyan-400 bg-cyan-900/30 px-1.5 rounded">0°</span>
                        </div>
                        <input type="range" id="rot-z" min="-180" max="180" value="0" class="w-full">
                    </div>
                </div>
            </div>

            <!-- Fading -->
            <div class="control-group">
                <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-3">Edge Fading</h2>

                <div class="grid grid-cols-2 gap-3 mb-4">
                    <label
                        class="flex items-center space-x-2 cursor-pointer p-2 rounded bg-white/5 hover:bg-white/10 transition">
                        <input type="checkbox" id="fade-top" class="rounded border-gray-600 bg-gray-700" checked>
                        <span class="text-xs text-gray-300 font-medium">Top</span>
                    </label>
                    <label
                        class="flex items-center space-x-2 cursor-pointer p-2 rounded bg-white/5 hover:bg-white/10 transition">
                        <input type="checkbox" id="fade-bottom" class="rounded border-gray-600 bg-gray-700" checked>
                        <span class="text-xs text-gray-300 font-medium">Bottom</span>
                    </label>
                    <label
                        class="flex items-center space-x-2 cursor-pointer p-2 rounded bg-white/5 hover:bg-white/10 transition">
                        <input type="checkbox" id="fade-left" class="rounded border-gray-600 bg-gray-700">
                        <span class="text-xs text-gray-300 font-medium">Left</span>
                    </label>
                    <label
                        class="flex items-center space-x-2 cursor-pointer p-2 rounded bg-white/5 hover:bg-white/10 transition">
                        <input type="checkbox" id="fade-right" class="rounded border-gray-600 bg-gray-700">
                        <span class="text-xs text-gray-300 font-medium">Right</span>
                    </label>
                </div>

                <div>
                    <div class="flex justify-between mb-1.5">
                        <label class="text-xs text-gray-300 font-medium">Fade Strength</label>
                        <span id="fade-str-val"
                            class="text-xs font-mono text-cyan-400 bg-cyan-900/30 px-1.5 rounded">0.5</span>
                    </div>
                    <input type="range" id="fade-strength" min="0.1" max="1.5" step="0.1" value="0.5" class="w-full">
                </div>
            </div>

            <!-- Actions -->
            <div class="pt-2 flex flex-col space-y-3">
                <button id="reset-cam"
                    class="w-full px-4 py-2.5 bg-gray-800 hover:bg-gray-700 text-gray-300 hover:text-white text-xs font-bold uppercase tracking-wider rounded-lg border border-gray-700 transition-colors flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 16" />
                        <path d="M3 5v11h11" />
                    </svg>
                    Reset Camera
                </button>
                <button id="export-svg"
                    class="w-full px-4 py-3 bg-cyan-600 hover:bg-cyan-500 text-white text-xs font-bold uppercase tracking-wider rounded-lg shadow-lg shadow-cyan-900/30 transition-all transform hover:scale-[1.02] active:scale-95 flex justify-center items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 10 12 15 17 10" />
                        <line x1="12" x2="12" y1="15" x2="12" y2="3" />
                    </svg>
                    Export SVG
                </button>
            </div>
        </div>
    </div>

    <!-- Show UI Button -->
    <button id="show-ui"
        class="fixed bottom-6 right-6 bg-gray-900 hover:bg-gray-800 text-white p-3 rounded-full shadow-2xl border border-gray-700 z-40 transition-all hover:scale-110 hidden group">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
            class="group-hover:text-cyan-400 transition-colors">
            <line x1="4" x2="20" y1="12" y2="12" />
            <line x1="4" x2="20" y1="6" y2="6" />
            <line x1="4" x2="20" y1="18" y2="18" />
            <circle cx="15" cy="18" r="2" />
            <circle cx="9" cy="6" r="2" />
        </svg>
    </button>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Configuration ---
        const config = {
            fgColor: '#00ffff',
            bgColor: '#051020',
            density: 50, // Grid size (50x50)
            dotSize: 0.4,
            curvature: 0,
            wave: 0,
            rotX: 0,
            rotY: 0,
            rotZ: 0,
            fadeTop: true,
            fadeBottom: true,
            fadeLeft: false,
            fadeRight: false,
            fadeStrength: 0.5
        };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(config.bgColor);
        scene.fog = new THREE.Fog(config.bgColor, 20, 60);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 100;

        // --- Lighting (Subtle) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- Instanced Mesh Setup ---
        // We use InstancedMesh for high performance with thousands of dots
        let mesh;
        const dummy = new THREE.Object3D();
        const geometry = new THREE.CylinderGeometry(1, 1, 0.1, 32);
        geometry.rotateX(Math.PI / 2); // Rotate to face camera by default

        // Material
        const material = new THREE.MeshBasicMaterial({
            color: config.fgColor,
            transparent: true // Needed if we want opacity fading, though we use scaling primarily
        });

        function createDots() {
            if (mesh) {
                scene.remove(mesh);
                mesh.dispose();
            }

            const count = config.density * config.density;
            mesh = new THREE.InstancedMesh(geometry, material, count);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // Allow updates

            // Apply initial rotation
            mesh.rotation.set(
                THREE.Math.degToRad(config.rotX),
                THREE.Math.degToRad(config.rotY),
                THREE.Math.degToRad(config.rotZ)
            );

            scene.add(mesh);

            updateDots();
        }

        function updateDots() {
            if (!mesh) return;

            const time = performance.now() * 0.001;
            const size = config.density;
            const separation = 1.2; // Space between dots
            const totalWidth = size * separation;
            const offset = totalWidth / 2;

            let idx = 0;
            const center = new THREE.Vector3(0, 0, 0);

            for (let i = 0; i < size; i++) { // Y axis
                for (let j = 0; j < size; j++) { // X axis

                    // Normalized coordinates (0 to 1)
                    const u = j / (size - 1);
                    const v = i / (size - 1); // 0 at bottom, 1 at top usually

                    // Position
                    const x = (j * separation) - offset;
                    const y = (i * separation) - offset;

                    // Curvature Logic (Bend along X or Y)
                    // Simple parabolic curve: z = k * x^2
                    // Normalized X from -1 to 1 for curvature calculation
                    const normX = (u * 2) - 1;
                    const zCurve = (normX * normX) * -config.curvature * 5;

                    // Wave Effect
                    const zWave = Math.sin(normX * Math.PI * 2 + time) * config.wave;

                    dummy.position.set(x, y, zCurve + zWave);

                    // Rotation (Follow curvature normal slightly)
                    dummy.rotation.set(0, 0, 0);
                    if (config.curvature !== 0) {
                        // Very rough approximation of following the curve tangent
                        dummy.rotation.y = normX * config.curvature * 0.5;
                    }

                    // Scale Calculation based on Fading
                    let scaleFactor = config.dotSize;

                    // Fade Logic
                    const fadeRamp = config.fadeStrength * 2; // Steeper ramp

                    if (config.fadeLeft) {
                        scaleFactor *= Math.min(1, u * (1 / config.fadeStrength));
                    }
                    if (config.fadeRight) {
                        scaleFactor *= Math.min(1, (1 - u) * (1 / config.fadeStrength));
                    }
                    if (config.fadeBottom) {
                        scaleFactor *= Math.min(1, v * (1 / config.fadeStrength));
                    }
                    if (config.fadeTop) {
                        scaleFactor *= Math.min(1, (1 - v) * (1 / config.fadeStrength));
                    }

                    // Apply Scale
                    dummy.scale.set(scaleFactor, scaleFactor, scaleFactor);

                    // Commit Instance
                    dummy.updateMatrix();
                    mesh.setMatrixAt(idx++, dummy.matrix);
                }
            }
            mesh.instanceMatrix.needsUpdate = true;
        }


        // --- UI Logic ---
        const uiElements = {
            fgColor: document.getElementById('fg-color'),
            fgHex: document.getElementById('fg-hex'),
            bgColor: document.getElementById('bg-color'),
            bgHex: document.getElementById('bg-hex'),
            density: document.getElementById('density'),
            densityVal: document.getElementById('density-val'),
            dotSize: document.getElementById('dot-size'),
            sizeVal: document.getElementById('size-val'),
            curvature: document.getElementById('curvature'),
            curveVal: document.getElementById('curve-val'),
            wave: document.getElementById('wave'),
            waveVal: document.getElementById('wave-val'),
            rotX: document.getElementById('rot-x'),
            rotXVal: document.getElementById('rot-x-val'),
            rotY: document.getElementById('rot-y'),
            rotYVal: document.getElementById('rot-y-val'),
            rotZ: document.getElementById('rot-z'),
            rotZVal: document.getElementById('rot-z-val'),
            fadeTop: document.getElementById('fade-top'),
            fadeBottom: document.getElementById('fade-bottom'),
            fadeLeft: document.getElementById('fade-left'),
            fadeRight: document.getElementById('fade-right'),
            fadeStrength: document.getElementById('fade-strength'),
            fadeStrVal: document.getElementById('fade-str-val'),
            resetCam: document.getElementById('reset-cam'),
            exportSvg: document.getElementById('export-svg'),
            controls: document.getElementById('controls'),
            showUi: document.getElementById('show-ui'),
            toggleUi: document.getElementById('toggle-ui'),
        };

        // Listeners
        uiElements.fgColor.addEventListener('input', (e) => {
            config.fgColor = e.target.value;
            uiElements.fgHex.innerText = config.fgColor;
            material.color.set(config.fgColor);
        });

        uiElements.bgColor.addEventListener('input', (e) => {
            config.bgColor = e.target.value;
            uiElements.bgHex.innerText = config.bgColor;
            scene.background.set(config.bgColor);
            scene.fog.color.set(config.bgColor);
        });

        uiElements.density.addEventListener('input', (e) => {
            config.density = parseInt(e.target.value);
            uiElements.densityVal.innerText = config.density;
            createDots(); // Recreate mesh for count change
        });

        uiElements.dotSize.addEventListener('input', (e) => {
            config.dotSize = parseFloat(e.target.value);
            uiElements.sizeVal.innerText = config.dotSize;
            updateDots();
        });

        uiElements.curvature.addEventListener('input', (e) => {
            config.curvature = parseFloat(e.target.value);
            uiElements.curveVal.innerText = config.curvature;
            updateDots();
        });

        uiElements.wave.addEventListener('input', (e) => {
            config.wave = parseFloat(e.target.value);
            uiElements.waveVal.innerText = config.wave;
            // updateDots handled in animation loop for wave
        });

        // Rotation Listeners
        const updateRotation = () => {
            config.rotX = parseFloat(uiElements.rotX.value);
            config.rotY = parseFloat(uiElements.rotY.value);
            config.rotZ = parseFloat(uiElements.rotZ.value);

            uiElements.rotXVal.innerText = config.rotX + '°';
            uiElements.rotYVal.innerText = config.rotY + '°';
            uiElements.rotZVal.innerText = config.rotZ + '°';

            if (mesh) {
                mesh.rotation.set(
                    THREE.Math.degToRad(config.rotX),
                    THREE.Math.degToRad(config.rotY),
                    THREE.Math.degToRad(config.rotZ)
                );
            }
        };

        [uiElements.rotX, uiElements.rotY, uiElements.rotZ].forEach(el => el.addEventListener('input', updateRotation));

        // Fade Listeners
        const updateFade = () => {
            config.fadeTop = uiElements.fadeTop.checked;
            config.fadeBottom = uiElements.fadeBottom.checked;
            config.fadeLeft = uiElements.fadeLeft.checked;
            config.fadeRight = uiElements.fadeRight.checked;
            config.fadeStrength = parseFloat(uiElements.fadeStrength.value);
            uiElements.fadeStrVal.innerText = config.fadeStrength;
            updateDots();
        };

        [uiElements.fadeTop, uiElements.fadeBottom, uiElements.fadeLeft, uiElements.fadeRight, uiElements.fadeStrength]
            .forEach(el => el.addEventListener('input', updateFade));

        // Reset Camera
        uiElements.resetCam.addEventListener('click', () => {
            controls.reset();
            camera.position.set(0, 0, 40);
        });

        // Export SVG
        uiElements.exportSvg.addEventListener('click', downloadSVG);

        function downloadSVG() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // SVG Header
            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="background-color: ${config.bgColor}">`;

            const dots = [];
            const size = config.density;
            const separation = 1.2;
            const totalWidth = size * separation;
            const offset = totalWidth / 2;
            const time = performance.now() * 0.001; // Use current time for wave snapshot

            // Helper vector
            const pos = new THREE.Vector3();
            const rotMatrix = new THREE.Matrix4();
            rotMatrix.makeRotationFromEuler(new THREE.Euler(
                THREE.Math.degToRad(config.rotX),
                THREE.Math.degToRad(config.rotY),
                THREE.Math.degToRad(config.rotZ)
            ));

            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const fov = camera.fov * Math.PI / 180;

            for (let i = 0; i < size; i++) { // Y axis
                for (let j = 0; j < size; j++) { // X axis

                    const u = j / (size - 1);
                    const v = i / (size - 1);

                    const x = (j * separation) - offset;
                    const y = (i * separation) - offset;

                    const normX = (u * 2) - 1;
                    const zCurve = (normX * normX) * -config.curvature * 5;
                    const zWave = Math.sin(normX * Math.PI * 2 + time) * config.wave;

                    // Calculate Scale Factor (same as updateDots)
                    let scaleFactor = config.dotSize;
                    if (config.fadeLeft) scaleFactor *= Math.min(1, u * (1 / config.fadeStrength));
                    if (config.fadeRight) scaleFactor *= Math.min(1, (1 - u) * (1 / config.fadeStrength));
                    if (config.fadeBottom) scaleFactor *= Math.min(1, v * (1 / config.fadeStrength));
                    if (config.fadeTop) scaleFactor *= Math.min(1, (1 - v) * (1 / config.fadeStrength));

                    // 1. Local Position
                    pos.set(x, y, zCurve + zWave);

                    // 2. Apply Mesh Rotation (World Transform)
                    pos.applyMatrix4(rotMatrix);

                    // 3. Distance to camera (for sorting)
                    const distSq = pos.distanceToSquared(camera.position);

                    // 4. Calculate Screen Radius (Perspective)
                    // Project position to get depth along camera view axis
                    const vecToPoint = new THREE.Vector3().copy(pos).sub(camera.position);
                    const depth = vecToPoint.dot(camDir);

                    // Geometry radius is 1. Scaled by scaleFactor.
                    const worldRadius = 1 * scaleFactor;
                    // Screen radius calculation based on perspective projection
                    const scale = height / (2 * Math.tan(fov / 2) * depth);
                    const screenR = worldRadius * scale;

                    // 5. Project to Screen Coordinates
                    pos.project(camera);

                    // 6. Check visibility (simple NDC check + depth check)
                    // Note: We include points slightly outside NDC because their radius might overlap screen
                    if (depth > 0 && pos.z < 1 && pos.x >= -1.2 && pos.x <= 1.2 && pos.y >= -1.2 && pos.y <= 1.2) {

                        const screenX = (pos.x * 0.5 + 0.5) * width;
                        const screenY = (-(pos.y * 0.5) + 0.5) * height; // Invert Y for SVG

                        if (screenR > 0.5) { // Optimization: don't draw tiny invisible dots
                            dots.push({
                                x: screenX,
                                y: screenY,
                                r: Math.abs(screenR),
                                dist: distSq,
                                color: config.fgColor
                            });
                        }
                    }
                }
            }

            // Sort: Furthest first (Painter's algorithm)
            dots.sort((a, b) => b.dist - a.dist);

            dots.forEach(dot => {
                svgContent += `<circle cx="${dot.x.toFixed(2)}" cy="${dot.y.toFixed(2)}" r="${dot.r.toFixed(2)}" fill="${dot.color}" />`;
            });

            svgContent += `</svg>`;

            // Download
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dot_pattern.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Toggle UI
        uiElements.toggleUi.addEventListener('click', () => {
            uiElements.controls.classList.add('translate-x-[120%]', 'opacity-0', 'pointer-events-none');
            uiElements.showUi.classList.remove('hidden');
        });

        uiElements.showUi.addEventListener('click', () => {
            uiElements.controls.classList.remove('translate-x-[120%]', 'opacity-0', 'pointer-events-none');
            uiElements.showUi.classList.add('hidden');
        });

        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Initialization ---
        createDots();

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // If wave is active, we need to update geometry every frame
            if (config.wave > 0) {
                updateDots();
            }

            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>

</html>