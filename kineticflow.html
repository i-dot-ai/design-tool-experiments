<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinetic Flow - Vector Wave Generator</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Load Babel for JSX support in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Custom scrollbar to match the dark theme */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #171717;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #525252;
        }
        body { margin: 0; background: #0a0a0a; overflow: hidden; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Icon Components (Inline SVG) ---
        // Replicating Lucide icons as simple components for standalone usage
        const IconBase = ({ children, size = 24, className = "" }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} height={size} 
                viewBox="0 0 24 24" 
                fill="none" stroke="currentColor" 
                strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" 
                className={className}
            >
                {children}
            </svg>
        );

        const Download = (props) => (
            <IconBase {...props}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <polyline points="7 10 12 15 17 10" />
                <line x1="12" y1="15" x2="12" y2="3" />
            </IconBase>
        );

        const RefreshCw = (props) => (
            <IconBase {...props}>
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                <path d="M21 3v5h-5" />
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                <path d="M8 16H3v5" />
            </IconBase>
        );

        const ImageIcon = (props) => (
            <IconBase {...props}>
                <rect width="18" height="18" x="3" y="3" rx="2" ry="2" />
                <circle cx="9" cy="9" r="2" />
                <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" />
            </IconBase>
        );

        const Move = (props) => (
            <IconBase {...props}>
                <polyline points="5 9 2 12 5 15" />
                <polyline points="9 5 12 2 15 5" />
                <polyline points="15 19 12 22 9 19" />
                <polyline points="19 9 22 12 19 15" />
                <line x1="2" x2="22" y1="12" y2="12" />
                <line x1="12" x2="12" y1="2" y2="22" />
            </IconBase>
        );

        const Menu = (props) => (
            <IconBase {...props}>
                <line x1="4" x2="20" y1="12" y2="12" />
                <line x1="4" x2="20" y1="6" y2="6" />
                <line x1="4" x2="20" y1="18" y2="18" />
            </IconBase>
        );

        const X = (props) => (
            <IconBase {...props}>
                <path d="M18 6 6 18" />
                <path d="m6 6 12 12" />
            </IconBase>
        );

        const Zap = (props) => (
            <IconBase {...props}>
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" />
            </IconBase>
        );

        const GitFork = (props) => (
            <IconBase {...props}>
                <circle cx="12" cy="18" r="3" />
                <circle cx="6" cy="6" r="3" />
                <circle cx="18" cy="6" r="3" />
                <path d="M18 9v1a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V9" />
                <line x1="12" x2="12" y1="12" y2="15" />
            </IconBase>
        );

        // --- Logic Helper ---
        const mulberry32 = (a) => {
            return () => {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        };

        // --- Reusable Components ---
        const ControlSlider = ({ label, value, min, max, step, onChange }) => (
            <div className="space-y-2">
                <div className="flex justify-between items-center">
                <label className="text-xs font-medium text-neutral-300">{label}</label>
                <span className="text-xs font-mono text-neutral-500 bg-neutral-800 px-1.5 py-0.5 rounded">{value.toFixed(2).replace(/[.,]00$/, "")}</span>
                </div>
                <input 
                type="range" 
                min={min} max={max} step={step}
                value={value}
                onChange={(e) => onChange(parseFloat(e.target.value))}
                className="w-full accent-indigo-500 h-1 bg-neutral-700 rounded-lg appearance-none cursor-pointer hover:bg-neutral-600 transition-colors"
                />
            </div>
        );

        // --- Main App ---
        const App = () => {
            // State
            const [dimensions, setDimensions] = useState({ width: 800, height: 600 });
            const [seed, setSeed] = useState(Date.now());
            const [params, setParams] = useState({
                bgColor: '#050505',
                strokeColor: '#6366f1',
                density: 60,       
                tightness: 14,     
                amplitude: 30,     
                randomness: 0.2,   
                angle: -30,        
                lineWidth: 1.5,
                bend: 0.5,         
                spread: 1.2,       
                smoothness: 150,   
            });
            const [isPanelOpen, setIsPanelOpen] = useState(true);
            const canvasRef = useRef(null);

            // Logic: Generate Wave Data
            const generateWaveData = useCallback(() => {
                const rng = mulberry32(seed);
                const { width, height } = dimensions;
                const { density, tightness, amplitude, randomness, bend, spread, smoothness } = params;
                
                const diag = Math.sqrt(width * width + height * height);
                const renderLength = diag * 1.5; 
                const renderHeight = height * 0.8; 
                
                const lines = [];
                const xStep = renderLength / smoothness;
                
                const startX = (width - renderLength) / 2;
                const startY = (height - renderHeight) / 2;

                for (let i = 0; i < density; i++) {
                    const linePoints = [];
                    const v = (i / (density - 1)) - 0.5; 
                    
                    const lineNoise = rng() * randomness * 50;
                    const speedOffset = rng() * randomness * 20; 
                    
                    for (let j = 0; j <= smoothness; j++) {
                        const u = j / smoothness; 
                        const xPos = u * renderLength;
                        
                        const baseFreq = tightness / 50;
                        
                        let waveY = Math.sin(xPos * baseFreq + lineNoise) * amplitude;
                        waveY += Math.cos(xPos * (baseFreq * 2) + lineNoise + speedOffset) * (amplitude * 0.4);

                        const randomJitter = (rng() - 0.5) * amplitude * randomness;
                        
                        // Spread Factor
                        const spreadFactor = 1 + (u * spread);
                        
                        let finalY = (v * renderHeight + waveY + randomJitter) * spreadFactor;
                        
                        // Bend Factor
                        const bendOffset = Math.pow(u, 2) * bend * (renderHeight * 2);
                        finalY += bendOffset;

                        finalY += renderHeight / 2;

                        linePoints.push({
                            x: xPos + startX, 
                            y: finalY + startY
                        });
                    }
                    lines.push(linePoints);
                }
                return lines;
            }, [dimensions, params, seed]);

            // Render to Canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const { width, height } = dimensions;

                // Clear
                ctx.fillStyle = params.bgColor;
                ctx.fillRect(0, 0, width, height);

                const lines = generateWaveData();

                // Setup styles
                ctx.lineWidth = params.lineWidth;
                ctx.strokeStyle = params.strokeColor;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Glow
                ctx.shadowBlur = params.lineWidth * 2;
                ctx.shadowColor = params.strokeColor;

                // Transform
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate((params.angle * Math.PI) / 180);
                ctx.translate(-width / 2, -height / 2);

                lines.forEach(points => {
                    if (points.length < 2) return;
                    ctx.beginPath();
                    
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        const xc = (points[i].x + points[i-1].x) / 2;
                        const yc = (points[i].y + points[i-1].y) / 2;
                        ctx.quadraticCurveTo(points[i-1].x, points[i-1].y, xc, yc);
                    }
                    ctx.lineTo(points[points.length-1].x, points[points.length-1].y);
                    ctx.stroke();
                });

                ctx.restore();

            }, [generateWaveData, params, dimensions]);

            // Handle Resize
            useEffect(() => {
                const handleResize = () => {
                const container = document.getElementById('canvas-container');
                if (container) {
                    setDimensions({
                    width: container.clientWidth,
                    height: container.clientHeight
                    });
                }
                };
                window.addEventListener('resize', handleResize);
                handleResize();
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Export SVG
            const handleDownloadSVG = () => {
                const lines = generateWaveData();
                const { width, height } = dimensions;
                
                let pathData = '';

                lines.forEach(points => {
                if (points.length < 2) return;
                pathData += `<path d="M ${points[0].x.toFixed(2)} ${points[0].y.toFixed(2)} `;
                for (let i = 1; i < points.length; i++) {
                    const xc = (points[i].x + points[i-1].x) / 2;
                    const yc = (points[i].y + points[i-1].y) / 2;
                    pathData += `Q ${points[i-1].x.toFixed(2)} ${points[i-1].y.toFixed(2)} ${xc.toFixed(2)} ${yc.toFixed(2)} `;
                }
                const last = points[points.length - 1];
                pathData += `L ${last.x.toFixed(2)} ${last.y.toFixed(2)}" fill="none" stroke="${params.strokeColor}" stroke-width="${params.lineWidth}" stroke-linecap="round" stroke-linejoin="round" />\n`;
                });

                const svgContent = `
                <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="background-color: ${params.bgColor}">
                    <g transform="rotate(${params.angle}, ${width/2}, ${height/2})">
                    ${pathData}
                    </g>
                </svg>
                `;

                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `wave-beam-${Date.now()}.svg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            const updateParam = (key, value) => {
                setParams(prev => ({ ...prev, [key]: value }));
            };

            return (
                <div className="flex flex-col h-screen w-full bg-neutral-900 text-white font-sans overflow-hidden">
                
                {/* Header */}
                <header className="flex-none h-14 border-b border-neutral-800 flex items-center px-4 justify-between bg-neutral-900/90 backdrop-blur z-20">
                    <div className="flex items-center gap-2">
                    <Zap className="w-5 h-5 text-indigo-400" />
                    <h1 className="font-bold text-lg tracking-tight text-neutral-200">Kinetic Flow</h1>
                    </div>
                    <div className="flex items-center gap-3">
                        <button 
                        onClick={() => setIsPanelOpen(!isPanelOpen)}
                        className="md:hidden p-2 hover:bg-neutral-800 rounded-md transition-colors"
                        >
                        {isPanelOpen ? <X size={20}/> : <Menu size={20} />}
                        </button>
                        <button 
                        onClick={() => setSeed(Date.now())}
                        className="flex items-center gap-2 px-3 py-1.5 text-sm font-medium bg-neutral-800 hover:bg-neutral-700 rounded-md transition-colors border border-neutral-700"
                        >
                        <RefreshCw size={16} />
                        <span className="hidden sm:inline">Regenerate</span>
                        </button>
                        <button 
                        onClick={handleDownloadSVG}
                        className="flex items-center gap-2 px-3 py-1.5 text-sm font-medium bg-indigo-600 hover:bg-indigo-500 text-white rounded-md shadow-lg shadow-indigo-900/20 transition-all hover:scale-105 active:scale-95"
                        >
                        <Download size={16} />
                        <span className="hidden sm:inline">Export SVG</span>
                        </button>
                    </div>
                </header>

                {/* Main Layout */}
                <div className="flex-1 flex overflow-hidden relative">
                    
                    {/* Canvas Area */}
                    <div id="canvas-container" className="flex-1 bg-neutral-950 relative overflow-hidden flex items-center justify-center p-4">
                    <canvas
                        ref={canvasRef}
                        width={dimensions.width}
                        height={dimensions.height}
                        className="w-full h-full object-contain shadow-2xl rounded-sm"
                        style={{ maxHeight: '100%', maxWidth: '100%' }}
                    />
                    </div>

                    {/* Controls Sidebar */}
                    <div 
                        className={`
                            fixed inset-y-0 right-0 w-80 bg-neutral-900 border-l border-neutral-800 shadow-2xl transform transition-transform duration-300 z-10 
                            md:relative md:transform-none md:w-80 flex flex-col
                            ${isPanelOpen ? 'translate-x-0' : 'translate-x-full'}
                        `}
                        style={{top: '3.5rem'}} // Below header
                    >
                    <div className="flex-1 overflow-y-auto p-6 space-y-8 custom-scrollbar">
                        
                        {/* Colors */}
                        <div className="space-y-4">
                        <div className="flex items-center gap-2 mb-2">
                            <ImageIcon size={16} className="text-neutral-500" />
                            <span className="text-xs font-bold uppercase tracking-wider text-neutral-500">Appearance</span>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-4">
                            <div className="space-y-2">
                            <label className="text-xs text-neutral-400">Background</label>
                            <div className="flex items-center gap-2 bg-neutral-800 p-1 rounded border border-neutral-700">
                                <input 
                                type="color" 
                                value={params.bgColor}
                                onChange={(e) => updateParam('bgColor', e.target.value)}
                                className="w-8 h-8 rounded cursor-pointer bg-transparent border-none"
                                />
                                <span className="text-xs font-mono text-neutral-400 truncate">{params.bgColor}</span>
                            </div>
                            </div>
                            <div className="space-y-2">
                            <label className="text-xs text-neutral-400">Stroke</label>
                            <div className="flex items-center gap-2 bg-neutral-800 p-1 rounded border border-neutral-700">
                                <input 
                                type="color" 
                                value={params.strokeColor}
                                onChange={(e) => updateParam('strokeColor', e.target.value)}
                                className="w-8 h-8 rounded cursor-pointer bg-transparent border-none"
                                />
                                <span className="text-xs font-mono text-neutral-400 truncate">{params.strokeColor}</span>
                            </div>
                            </div>
                        </div>

                        <div className="space-y-1 pt-2">
                            <div className="flex justify-between">
                                <label className="text-xs text-neutral-400">Line Width</label>
                                <span className="text-xs font-mono text-neutral-500">{params.lineWidth}px</span>
                            </div>
                            <input 
                                type="range" min="0.5" max="10" step="0.5"
                                value={params.lineWidth}
                                onChange={(e) => updateParam('lineWidth', parseFloat(e.target.value))}
                                className="w-full accent-indigo-500 h-1 bg-neutral-700 rounded-lg appearance-none cursor-pointer"
                            />
                        </div>
                        </div>

                        <hr className="border-neutral-800" />

                        {/* Beam Shape */}
                        <div className="space-y-6">
                        <div className="flex items-center gap-2 mb-2">
                            <GitFork size={16} className="text-neutral-500" />
                            <span className="text-xs font-bold uppercase tracking-wider text-neutral-500">Beam Shape</span>
                        </div>

                        <ControlSlider 
                            label="Spread (Zoom)" 
                            value={params.spread} 
                            min={-0.5} max={3} step={0.1} 
                            onChange={(v) => updateParam('spread', v)} 
                        />
                        <ControlSlider 
                            label="Bend (Arc)" 
                            value={params.bend} 
                            min={-1.5} max={1.5} step={0.05} 
                            onChange={(v) => updateParam('bend', v)} 
                        />
                        <ControlSlider 
                            label="Direction" 
                            value={params.angle} 
                            min={-180} max={180} step={1} 
                            onChange={(v) => updateParam('angle', v)} 
                        />
                        </div>

                        <hr className="border-neutral-800" />

                        {/* Wave Details */}
                        <div className="space-y-6">
                        <div className="flex items-center gap-2 mb-2">
                            <Move size={16} className="text-neutral-500" />
                            <span className="text-xs font-bold uppercase tracking-wider text-neutral-500">Wave Dynamics</span>
                        </div>

                        <ControlSlider 
                            label="Density" 
                            value={params.density} 
                            min={5} max={150} step={1} 
                            onChange={(v) => updateParam('density', v)} 
                        />
                        <ControlSlider 
                            label="Tightness" 
                            value={params.tightness} 
                            min={1} max={50} step={1} 
                            onChange={(v) => updateParam('tightness', v)} 
                        />
                        <ControlSlider 
                            label="Amplitude" 
                            value={params.amplitude} 
                            min={0} max={100} step={1} 
                            onChange={(v) => updateParam('amplitude', v)} 
                        />
                        <ControlSlider 
                            label="Randomness" 
                            value={params.randomness} 
                            min={0} max={2} step={0.05} 
                            onChange={(v) => updateParam('randomness', v)} 
                        />
                        </div>

                    </div>
                    
                    <div className="p-4 border-t border-neutral-800 text-center">
                        <p className="text-[10px] text-neutral-600">
                        Play with Spread and Bend to aim the flow.
                        </p>
                    </div>
                    </div>
                </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
